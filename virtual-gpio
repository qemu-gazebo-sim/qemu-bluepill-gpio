#!/usr/bin/env python3
import re
import os
import sys
import pexpect
import time

SOCK_PATH="/tmp/tmp-gpio.sock"
GPIO_RANGE=[0x40010c00, 0x40011000]
IC_RANGE  =[0x40010400, 0x40010800]

GPIO_SET_OFFSET=0x0
GPIO_RESET_OFFSET=0x4
GPIO_READ_OFFSET=0xc

class VGPIOManager(object):
    fd = None
    def __init__(self, spath=SOCK_PATH):
        self.load(spath)

    def load(self, spath=SOCK_PATH):
        if os.path.exists(SOCK_PATH):
            os.unlink(SOCK_PATH)

        self.fd = pexpect.spawn("socat - UNIX-LISTEN:{}".format(SOCK_PATH))

    def validate_address(self, address):
        if address < GPIO_RANGE[0] or address > GPIO_RANGE[1]:
            return False
        return True

    def writel(self, address, value):
        self._sendline('writel 0x{:x} 0x{:x}'.format(address, value))
        return self._read()

    def readl(self, address):
        self._sendline('readl 0x{:x}'.format(address))
        return self._read()

    def read(self, address, size):
        self._sendline('read 0x{:x} 0x{:x}'.format(address, size))
        return self._read()

    def _sendline(self, s):
        return self.fd.sendline(s)

    def _read(self):
        # Cancel echo
        try:
            value = ''
            while not ("OK" in value):
                value = self.fd.readline()
                value = value.decode("utf-8")
            return value
        except:
            return None

    def read_entire_gpio_area(self):
        v = self.read(GPIO_RANGE[0], 0x400)
        return v

    def close(self):
        self.fd.close()

    def help(self):
        s  = "[ ] Virtual GPIO manager\n"
        s += "    Usage:\n"
        s += "    help                     -- this help message\n"
        s += "    get <gpionum>            -- read a specific gpio\n"
        s += "    set <gpionum> <value>    -- Set a gpio to a specific value\n"
        s += "    toggle <gpionum>         -- change the value of the gpio\n"
        s += "    read-area                -- read entire gpio area\n"
        s += "    read-ic                  -- read entire interrupt controller area\n"
        s += "    readl <address>          -- read 32 bit from address\n"
        s += "    writel <address> <value> -- read 32 bit from address\n"
        s += "    exit                     -- exit from program\n"
        s += "    reload                   -- restart the initialization\n"
        return s

    def read_ic_area(self):
        v = self.read(IC_RANGE[0], 0x200)
        return v

    def get_gpio_location(self, num):
        if num > 64 or num < 0:
            return 0
        return GPIO_RANGE[0] + 0x4*int(num / 64)

    def set(self, gpionum, value, offset=GPIO_SET_OFFSET, state = 1):
        m = self.get_gpio_location(gpionum)
        if value:
            m += offset
        else:
            m += GPIO_RESET_OFFSET
        
        v = int(self.readl(m).split()[1], 0)
        gpio = 1 << (gpionum % 64)
        if state == 1:
            new_value = v | gpio
        else:
            new_value = v & (~gpio)

        return self.writel(m, new_value)

    def get(self, gpionum, offset=GPIO_READ_OFFSET):
        m = self.get_gpio_location(gpionum) + offset
        v = int(self.readl(m).split()[1], 0)
        gpio = 1 << (gpionum % 32)

        return str((v & gpio)!=0)

    def toggle(self, gpionum):
        v = self.get(gpionum)
        print("value: {}".format(v))
        return self.set(gpionum, not v)

    def parse(self, s):
        s = s.split(' ')
        c = s[0]

        if c == 'help':
            return self.help()
        elif c == 'TEST_SET':
            for i in range (0,64):
                print(f"{i} : {self.set(i, int(s[1]))}")
            return "Finalizado"
        elif c == 'TEST_GET':
            for i in range (0,64):
                print(f"{i} : {self.get(i)}")
        elif c == 'TEST_READ':
            init = GPIO_READ_OFFSET
            for i in range(0,64):
                self.get(0, init)
                init += 0x8
            return "Finalizado"
        elif c == "TEST2":
            return (self.writel(int(0x40010c00), 512))
        elif c == "TEST3":
            return (self.readl(int(0x40010c00)))
        elif c == 'get':
            if len(s) < 2:
                return "Error: get requires 1 argument"
            return self.get(int(s[1], 0))
        elif c == 'set':
            if len(s) < 3:
                return "Error: set requires 2 arguments"
            return self.set(int(s[1], 0), int(s[2], 0))
        elif c == 'read-area':
            return self.read_entire_gpio_area()
        elif c == 'read-ic':
            return self.read_ic_area()
        elif c == 'readl':
            if len(s) < 2:
                return "Error: read requires 1 argument"
            return self.readl(int(s[1], 0))
        elif c == 'writel':
            if len(s) < 3:
                return "Error: write requires 2 arguments"
            return self.writel(int(s[1], 0), int(s[2],0))
        elif c == 'exit':
            self.close()
            sys.exit(0)
        elif c == 'toggle':
            if len(s) < 2:
                return "Error: toggle requires 1 argument"
            return self.toggle(int(s[1]))
        elif c == 'reload':
            return self.load()
        return ""

if __name__=="__main__":
    print('[ ] Virtual GPIO manager')
    print('[ ] Listening for connections')
    vgpio = VGPIOManager()
    while True:
        cmd = input('(gpio)> ')
        print(vgpio.parse(cmd))
    vgpio.close()
